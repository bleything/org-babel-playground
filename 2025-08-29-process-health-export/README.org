# -*- truncate-lines: nil; org-confirm-babel-evaluate: nil -*-
#+startup: show3levels indent

* Processing Apple Health Exports
  :properties:
  :header-args: :noweb-sep "\n\n"
  :end:

/note: this is an early draft with several issues, mainly that the code is very/
/inefficient. I'll clean it all up soon, in the mean time no judgies/

I want to display my Apple Health workouts on my website without giving away any
sensitive info. I'm using an iOS app called [[https://healthyapps.dev][Health Auto Export]] to export the
workouts as JSON and it returns the data in a format that's pretty much ready to
use, but it includes a lot of PII that needs to be cleaned up.

Let's take a look at the export format and write a script to clean it up.

** Prerequisites

To run the Ruby code you'll need a Ruby with a built-in =json= library. I don't
think I use any modern features but I only tested on 3.3.x.

To use this document open it in emacs 24 or later, or earlier if you have org
and babel set up. You'll be prompted to apply some unsafe variables. It's
complaining about =org-confirm-babel-evalute: nil= at the top of the file which
disables a confirmation prompt before evaluating a code block. Up to you whether
you want to keep it.

You'll also need the data. Use the Auto Export feature in Health Auto Export to
save a json file of just your workouts. Put that file in this directory called
~export.json~. After you run the script at the end you can find the output in
~walks.json~.

There might be sample data available on the internet but I haven't looked. I'll
add some anonymized samples here later, for reference.

** The Export Data Format

The author of Health Auto Export kindly provides [[https://github.com/Lybron/health-auto-export/wiki/API-Export---JSON-Format#workouts][detailed documentation]] for the
export format but it doesn't fully match up with what I'm seeing when I use the
app. Keep a tab open to that for reference but I'll go over the relevant bits
below.

*** Conventions

There are a few conventions that the export file follows:

- every workout has an =id= property that contains a UUID
- timestamps are represented as strings of the format =yyyyy-MM-dd HH:mm:ss Z=
- numbers are (almost[fn:: except humidity]) always floats with many decimal
  places

Some metrics are provided in an expanded format, presumably to allow for
localized units. We'll revisit these later:

#+begin_src json
"activeEnergyBurned" : {
    "qty" : 275.08747574094002,
    "units" : "kcal"
},
#+end_src

For metrics that are sampled periodically like heart rate or GPS route results
are provided as an array of objects. We'll look at several examples in detail a
bit later but here's the general idea:

#+begin_src json
"heartRateData" : [
    { sample: 1 },
    { sample: 2 },
    ...
],
#+end_src

*** Overall Structure

The export file is pretty straightforward. It's a JSON document with a single
top-level key called =data=. This is an object containing two keys: =workouts=
and =metrics=. In my exports =metrics= is always empty so we're going to ignore
it for now.

#+begin_src json
  {
    "data" : {
      "workouts": [...],
      "metrics": []
    }
  }
#+end_src

*** Workout Structure

=workouts= is an array of objects that each represent a single workout. It
contains a few simple keys, a bunch of the expanded metrics, and a handful of
arrays of sampled metrics. Here's a full list of what's in the export I'm
looking at right now:

- simple keys
  - =id= -- string
  - =name= -- string (e.g. "Outdoor Walk")
  - =start= -- timestamp
  - =end= -- timestamp
  - =duration= -- float (seconds)
  - =location= -- string (e.g. "Outdoor")

- complex keys
  - =activeEnergyBurned= -- float (kcal)
  - =distance= -- float (mi)
  - =elevationUp= -- float (ft)
  - =humidity= -- int (percent)
  - =intensity= -- float (kcal/hr*kg)
  - =metadata= -- object (always empty in my exports)
  - =temperature= -- float (degF)

- sampled
  - =activeEnergy=
  - =heartRateData=
  - =heartRateRecovery=
  - =stepCount=
  - =walkingAndRunningDistance=

I've noticed that export fields are sometimes excluded if there's no data. For
example, on a walk with no elevation change the =elevationUp= key might be
missing or empty. That means that there might be fields missing from this one
too. It might be worth analyzing what we have to look for other fields but we'll
get back to that.

** Processing the data

Let's load up the export data and get to work. To briefly recap, the plan here
is to iterate over the exported data and cherry-pick the stuff we want. Along
the way we'll also reshape it to make it more convenient to work with and
anonymize some of it.

*** Step 0: Loading and Basic Cleanup

#+begin_src ruby :noweb-ref load
  require 'json'

  export = JSON.load_file("export.json")
  workouts = export['data']['workouts']
#+end_src


First we want to replace the =start= and =end= timestamps with a =date= and
=time_of_day= field. This is an effort to balance privacy with exposing relevant
data. I don't necessarily want to advertise when I'm out of my house, but I do
want to be able to know if it was morning, afternoon, etc.

The time of day calculation is not very smart. For example, a walk that starts
at 11:59am will be reported as a morning walk. I will probably revisit this
later.

We'll also delete a bunch of fields we don't want.

#+begin_src ruby :noweb-ref cleanup
  filtered = workouts.map do |workout|
    start = Time.new(workout.delete 'start')
    workout.delete 'end'

    workout['date'] = start.strftime("%Y-%m-%d")

    workout['time_of_day'] = case start.hour
                             when 0..4
                               "night"
                             when 5..11
                               "morning"
                             when 12..16
                               "afternoon"
                             when 18..21
                               "evening"
                             when 22..24
                               "night"
                             else
                               "FIXME"
                             end

    workout.delete 'location'
    workout.delete 'name'

    workout.delete 'intensity'
    workout.delete 'metadata'

    workout.delete 'activeEnergy'
    workout.delete 'activeEnergyBurned'
    workout.delete 'heartRateRecovery'

    workout.delete 'route'
    workout.delete 'heartRateData'
    workout.delete 'walkingAndRunningDistance'

    workout
  end
#+end_src

*** Step 1: Flatten Complex Keys

In the website code we do a lot of sums and averages of the complex fields so to
make writing that code more convenient we're going to pull everything out of the
objects and into top level keys.

#+begin_src ruby :noweb-ref flatten-complex-keys
  targets = %w[
    distance elevationUp humidity intensity temperature
  ]

  filtered.map! do |workout|
    targets.each do |target|
      next unless workout[target]

      workout["#{target}_qty"] = workout[target]['qty']
      workout["#{target}_units"] = workout[target]['units']
      workout.delete target
    end

    workout
  end
#+end_src

*** Step 2: Aggregate Step Count

=stepCount= is recorded as a series of samples at 1 second intervals. A single
record looks like this:

#+begin_src js
  {
      "source": "watch|phone",
      "date": "2025-08-24 06:31:34 -0700",
      "qty": 86.08579514803237,
      "units": "steps"
  },
#+end_src

=source= is a pipe-separated list of devices that participated in the sample,
given as the name of the device. I've redacted my device names in this
example. Everything else is what it looks like, but I'm not sure why =units= is
in there. I'm not sure what other units there could be?

We're going to want the sampled data later for drawing graphs so we won't remove
it entirely but we are going to add up the steps now and insert it as a field at
the top level, just to save us some complexity in the frontend code. We'll also
strip out the =source= and =units= fields to cut down on file size. No need to
carry around a bunch of strings we don't need.

#+begin_src ruby :noweb-ref aggregate-step-count
  filtered.map! do |workout|
    next unless workout['stepCount']

    # this should almost always be "steps" and I'd be tempted to hard-code that but
    # without a way to be sure I think it's safer to just leave a trap in here so we
    # can address it if it comes up
    units = workout['stepCount'].map {|sc| sc['units'] }.uniq
    raise "unknown stepCount units: #{units.join ' '}" if units.size > 1

    workout['stepCount_units'] = units.first
    workout['stepCount_qty'] = workout['stepCount'].map {|sc| sc['qty'] }.sum

    workout['stepCount'].map! do |sc|
      sc.delete 'source'
      sc.delete 'units'

      sc
    end

    workout
  end
#+end_src

*** Wrapping Up

Alright, that's it. Let's save our new file and report what we've done. The
=JSON.pretty_generate= version is useful if you're making changes to this
script, otherwise you should use the =to_json= version. The space savings are
significant.

#+begin_src ruby :noweb-ref save-and-report
  File.open('walks.json', 'w') {|f| f.puts filtered.to_json }
  # File.open('walks.json', 'w') {|f| f.puts JSON.pretty_generate(filtered) }

  old_size = File.size("export.json")
  new_size = File.size("walks.json")

  # cast these to floats so we get more resolution for the percentage calc
  reduction = (old_size - new_size).to_f / old_size.to_f

  puts "Processed %i workouts. File size reduced by %.2f%%, from %i to %i bytes" % [
    filtered.count,
    reduction * 100.0,
    old_size,
    new_size
  ]
#+end_src

** The Final Script

If you're reading this in emacs you should be able to put your point in this
code block and press ~C-c C-c~ to run it. You'll know it worked when a
~#+RESULTS:~ block appears below it. It might take a few seconds.

#+begin_src ruby :tangle process-health-export.rb :noweb yes :results output
  #!/usr/bin/env ruby

  ### WARNING: This file is generated by babel. Changes will be lost.

  <<load>>

  ### remove unwanted fields

  <<cleanup>>

  ### flatten complex keys

  <<flatten-complex-keys>>

  ### aggregate step count

  <<aggregate-step-count>>

  ### save and report

  <<save-and-report>>
#+end_src

#+RESULTS:
: Processed 59 workouts. File size reduced by 99.78%, from 108285564 to 240643 bytes
